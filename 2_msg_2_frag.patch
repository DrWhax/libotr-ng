diff --git a/src/fragment.c b/src/fragment.c
index 4d83b54..5bcc7cb 100644
--- a/src/fragment.c
+++ b/src/fragment.c
@@ -198,6 +198,7 @@ tstatic otrng_err append_fragment(const char *msg, int msg_len,
   return SUCCESS;
 }
 
+// TODO: Rename to is_not_fragment after boolean refactoring
 tstatic otrng_bool is_fragment(const string_p message) {
   if (strstr(message, "?OTR|") != NULL)
     return otrng_true;
diff --git a/src/test/test.c b/src/test/test.c
index efd9a23..401ef09 100644
--- a/src/test/test.c
+++ b/src/test/test.c
@@ -161,6 +161,8 @@ int main(int argc, char **argv) {
                   test_defragment_single_fragment);
   g_test_add_func("/fragment/defragment_fails_without_comma",
                   test_defragment_without_comma_fails);
+  g_test_add_func("/fragment/defragment_two_distinct_messages",
+                  test_defragment_two_distinct_messages);
   g_test_add_func("/fragment/fails_for_invalid_tag",
                   test_defragment_fails_for_invalid_tag);
   g_test_add_func("/fragment/defragment_regular_otr_message",
diff --git a/src/test/test_fragment.c b/src/test/test_fragment.c
index 484819d..a37238f 100644
--- a/src/test/test_fragment.c
+++ b/src/test/test_fragment.c
@@ -119,6 +119,56 @@ void test_defragment_without_comma_fails(void) {
   otrng_fragment_context_free(context);
 }
 
+void test_defragment_two_distinct_messages(void) {
+  string_p msg1_fragments[2];
+  string_p msg2_fragments[2];
+  msg1_fragments[0] = "?OTR|00000001|00000001|00000002,00001,00002,first fra,";
+  msg1_fragments[1] = "?OTR|00000001|00000001|00000002,00002,00002,g msg,";
+  msg2_fragments[0] = "?OTR|00000002|00000001|00000002,00001,00002,second fr,";
+  msg2_fragments[1] = "?OTR|00000002|00000001|00000002,00002,00002,ag msg,";
+
+  char *unfrag1 = NULL;
+  char *unfrag2 = NULL;
+  fragment_context_s *context;
+  context1 = otrng_fragment_context_new();
+  context = otrng_fragment_context_new();
+
+  otrng_assert(otrng_unfragment_message(&unfrag1, context, msg1_fragments[0], 2) ==
+               SUCCESS);
+  otrng_assert(context->status == FRAGMENT_INCOMPLETE);
+  g_assert_cmpint(context->N, ==, 2);
+  g_assert_cmpint(context->K, ==, 1);
+  g_assert_cmpstr(context->fragment, ==, "first fra");
+  g_assert_cmpint(context->fragment_len, ==, 9);
+
+  otrng_assert(otrng_unfragment_message(&unfrag2, context, msg2_fragments[0], 2) ==
+               SUCCESS);
+  otrng_assert(context->status == FRAGMENT_INCOMPLETE);
+  g_assert_cmpint(context->N, ==, 2);
+  g_assert_cmpint(context->K, ==, 1);
+  g_assert_cmpstr(context->fragment, ==, "second fr");
+  g_assert_cmpint(context->fragment_len, ==, 9);
+
+  otrng_assert(otrng_unfragment_message(&unfrag1, context, msg1_fragments[1], 2) ==
+               SUCCESS);
+  otrng_assert(context->status == FRAGMENT_COMPLETE);
+  g_assert_cmpint(context->N, ==, 2);
+  g_assert_cmpint(context->K, ==, 2);
+  g_assert_cmpstr(context->fragment, ==, NULL);
+  g_assert_cmpint(context->fragment_len, ==, 14);
+  g_assert_cmpstr(unfrag1, ==, "first frag msg");
+
+  otrng_assert(otrng_unfragment_message(&unfrag2, context, msg2_fragments[1], 2) ==
+               SUCCESS);
+  otrng_assert(context->status == FRAGMENT_COMPLETE);
+  g_assert_cmpint(context->N, ==, 2);
+  g_assert_cmpint(context->K, ==, 2);
+  g_assert_cmpstr(context->fragment, ==, NULL);
+  g_assert_cmpint(context->fragment_len, ==, 15);
+  g_assert_cmpstr(unfrag2, ==, "second frag msg");
+
+}
+
 void test_defragment_clean_context_for_frag_out_of_order(void) {
   string_p fragments[3];
   fragments[0] = "?OTR|00000000|00000001|00000002,00001,00003,one more ,";
